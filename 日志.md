# TraceId 功能实现文档

本文档记录了在 NestJS + Prisma 项目中实现 TraceId 全链路追踪功能的完整过程。

## 1. 功能概述

实现了完整的请求追踪系统，包括：
- 为每个请求生成唯一的 traceId
- 在响应头和响应体中返回 traceId
- 在所有日志中包含 traceId，便于问题定位
- 日志持久化到文件系统
- 统一的成功和错误响应格式

## 2. TraceId 全链路追踪流程

traceId 从生成到提供给用户的完整链路如下：

1. **请求到达**：客户端发起 HTTP 请求
2. **中间件生成**：TraceIdMiddleware 拦截请求，生成唯一的 traceId
3. **请求存储**：将 traceId 存储到请求对象中，供后续处理使用
4. **响应头设置**：将 traceId 设置到响应头 X-Trace-Id 中
5. **业务处理**：在控制器和各种服务中，通过请求对象访问 traceId
6. **日志记录**：在日志拦截器和异常过滤器中，使用 traceId 记录相关信息
7. **响应体注入**：在响应拦截器中，将 traceId 注入到响应体中
8. **返回客户端**：客户端收到包含 traceId 的响应（响应头和响应体）

通过这个完整的链路，我们可以实现端到端的请求追踪，便于问题定位和调试。

## 3. 依赖安装

```bash
pnpm add uuid winston
```

## 4. 实现步骤

### 3.1 创建 TraceId 中间件

**文件路径**：[src/middleware/trace-id.middleware.ts](./src/middleware/trace-id.middleware.ts)

```typescript
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class TraceIdMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // 生成或获取 traceId
    const traceId = req.headers['x-trace-id'] as string || uuidv4();
    
    // 将 traceId 存储到请求对象中
    (req as any).traceId = traceId;
    
    // 添加到响应头中
    res.setHeader('X-Trace-Id', traceId);
    
    next();
  }
}
```

### 3.2 注册中间件

**文件路径**：[src/app.module.ts](./src/app.module.ts)

```typescript
import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PhoneController } from './phone/phone.controller';
import { PhoneService } from './phone/phone.service';
import { PrismaService } from './prisma/prisma.service';
import { TraceIdMiddleware } from './middleware/trace-id.middleware';

@Module({
  imports: [],
  controllers: [AppController, PhoneController],
  providers: [AppService, PrismaService, PhoneService],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(TraceIdMiddleware).forRoutes('*');
  }
}
```

### 3.3 创建全局响应拦截器

**文件路径**：[src/common/interceptors/response.interceptor.ts](./src/common/interceptors/response.interceptor.ts)

```typescript
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { Request, Response } from 'express';

// 定义响应格式接口
interface ResponseFormat<T> {
  success: boolean;
  data: T;
  traceId: string;
}

@Injectable()
export class ResponseInterceptor<T> implements NestInterceptor<T, ResponseFormat<T>> {
  intercept(context: ExecutionContext, next: CallHandler): Observable<ResponseFormat<T>> {
    // 获取请求对象
    const ctx = context.switchToHttp();
    const request = ctx.getRequest<Request>();
    
    // 获取 traceId
    const traceId = (request as any).traceId || 'unknown';
    
    // 处理响应
    return next.handle().pipe(
      map(data => ({
        success: true,
        data,
        traceId,
      })),
    );
  }
}
```

### 3.4 创建全局异常过滤器

**文件路径**：[src/common/filters/global-exception.filter.ts](./src/common/filters/global-exception.filter.ts)

```typescript
import { ExceptionFilter, Catch, ArgumentsHost, HttpStatus, Logger } from '@nestjs/common';
import { Request, Response } from 'express';

@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger(GlobalExceptionFilter.name);

  catch(exception: any, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    // 获取 traceId
    const traceId = (request as any).traceId || 'unknown';

    // 记录错误堆栈，方便后端调试（包含 traceId）
    this.logger.error(
      `[${traceId}] Global error: ${exception.message}, Code: ${exception.code || 'N/A'}`,
      exception instanceof Error ? exception.stack : undefined
    );
    
    // 默认状态码和错误信息
    let status = HttpStatus.INTERNAL_SERVER_ERROR;
    let message = '操作失败，请稍后重试';
    
    // 根据错误类型返回不同的友好提示
    if (exception.code === 'P2025') { // Prisma 的 RecordNotFound 错误码
      status = HttpStatus.NOT_FOUND;
      // 生成更通用的提示信息，不固定使用 "id"
      message = '找不到对应的数据，请确认查询条件是否有效';
    } else if (exception.code === 'P2002') { // Prisma 的唯一约束错误码
      status = HttpStatus.BAD_REQUEST;
      message = '数据已存在，请检查输入';
    } else if (exception.message && exception.message.includes('Unknown argument')) {
      // 处理未知参数错误，提取参数名
      const unknownArgMatch = exception.message.match(/Unknown argument `(\w+)`/);
      if (unknownArgMatch && unknownArgMatch[1]) {
        const paramName = unknownArgMatch[1];
        message = `识别到未知参数 ${paramName}，请确认参数名是否正确`;
      } else {
        message = '识别到未知参数，请确认参数名是否正确';
      }
    } else if (exception.message && exception.message.includes('Invalid value provided')) {
      // 处理参数值无效错误，提取参数名、期望类型和实际类型
      const invalidValueMatch = exception.message.match(/Argument `(\w+)`: Invalid value provided\. Expected (.+), provided (.+)\./);
      if (invalidValueMatch && invalidValueMatch[1] && invalidValueMatch[2] && invalidValueMatch[3]) {
        const paramName = invalidValueMatch[1];
        const expectedType = invalidValueMatch[2];
        const providedType = invalidValueMatch[3];
        message = `参数 ${paramName} 类型错误，期望 ${expectedType} 类型，实际提供了 ${providedType} 类型`;
      } else {
        message = '参数值无效，请检查输入';
      }
    } else if (exception.message) {
      // 其他错误，使用完整的错误信息作为友好提示
      message = exception.message;
    }
    
    // 返回友好的错误响应（包含 traceId）
    response.status(status).json({
      success: false,
      message,
      traceId,
    });
  }
}
```

### 3.5 创建日志拦截器

**文件路径**：[src/common/interceptors/logging.interceptor.ts](./src/common/interceptors/logging.interceptor.ts)

```typescript
import { Injectable, NestInterceptor, ExecutionContext, CallHandler, Logger } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import { Request } from 'express';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  private readonly logger = new Logger(LoggingInterceptor.name);

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    // 获取请求对象
    const ctx = context.switchToHttp();
    const request = ctx.getRequest<Request>();
    
    // 获取 traceId
    const traceId = (request as any).traceId || 'unknown';
    
    // 获取控制器和方法信息
    const className = context.getClass().name;
    const methodName = context.getHandler().name;
    const url = request.url;
    const method = request.method;
    
    // 获取请求参数
    const body = request.body;
    const query = request.query;
    const params = request.params;
    
    // 记录方法开始执行的日志，包含入参
    const startTime = Date.now();
    this.logger.log(`[${traceId}] ${className}.${methodName} - ${method} ${url} - 开始执行`);
    this.logger.log(`[${traceId}] 请求参数: body=${JSON.stringify(body)}, query=${JSON.stringify(query)}, params=${JSON.stringify(params)}`);
    
    // 处理响应
    return next.handle().pipe(
      tap({
        next: (response) => {
          // 记录方法执行成功的日志，包含完整的响应结果
          const executionTime = Date.now() - startTime;
          this.logger.log(`[${traceId}] ${className}.${methodName} - 执行成功，耗时: ${executionTime}ms`);
          this.logger.log(`[${traceId}] 响应结果: ${JSON.stringify(response)}`);
        },
        error: (error) => {
          // 记录方法执行失败的日志，包含错误栈
          const executionTime = Date.now() - startTime;
          this.logger.error(`[${traceId}] ${className}.${methodName} - 执行失败，耗时: ${executionTime}ms`);
          this.logger.error(`[${traceId}] 错误信息: ${error.message}`);
          this.logger.error(`[${traceId}] 错误栈: ${error.stack || '无错误栈信息'}`);
        },
      }),
    );
  }
}
```

### 3.6 创建 Winston 日志服务

**文件路径**：[src/common/services/logger.service.ts](./src/common/services/logger.service.ts)

```typescript
import { Injectable, LoggerService } from '@nestjs/common';
import * as winston from 'winston';
import * as path from 'path';
import * as fs from 'fs';

@Injectable()
export class WinstonLoggerService implements LoggerService {
  private logger: winston.Logger;

  constructor() {
    // 确保日志目录存在
    const logDir = path.join(process.cwd(), 'logs');
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    
    // 配置 winston
    this.logger = winston.createLogger({
      level: 'info',
      format: winston.format.combine(
        winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
        winston.format.printf(({ timestamp, level, message }) => {
          return `${timestamp} ${level.toUpperCase()}: ${message}`;
        })
      ),
      transports: [
        // 控制台输出
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
            winston.format.printf(({ timestamp, level, message }) => {
              return `${timestamp} ${level.toUpperCase()}: ${message}`;
            })
          )
        }),
        // 文件输出（按日期分割）
        new winston.transports.File({
          filename: path.join(logDir, 'application-%DATE%.log'),
          maxsize: 5242880, // 5MB
          maxFiles: 10,
          tailable: true,
          format: winston.format.combine(
            winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
            winston.format.printf(({ timestamp, level, message }) => {
              return `${timestamp} ${level.toUpperCase()}: ${message}`;
            })
          )
        }),
        // 错误日志文件
        new winston.transports.File({
          filename: path.join(logDir, 'error-%DATE%.log'),
          level: 'error',
          maxsize: 5242880, // 5MB
          maxFiles: 10,
          tailable: true,
          format: winston.format.combine(
            winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
            winston.format.printf(({ timestamp, level, message }) => {
              return `${timestamp} ${level.toUpperCase()}: ${message}`;
            })
          )
        })
      ],
      exceptionHandlers: [
        new winston.transports.File({
          filename: path.join(logDir, 'exceptions-%DATE%.log'),
          maxsize: 5242880, // 5MB
          maxFiles: 10,
          tailable: true
        })
      ]
    });
  }

  log(message: any, context?: string): void {
    this.logger.info(typeof message === 'object' ? JSON.stringify(message) : message, { context });
  }

  error(message: any, stack?: string, context?: string): void {
    this.logger.error(typeof message === 'object' ? JSON.stringify(message) : message, { stack, context });
  }

  warn(message: any, context?: string): void {
    this.logger.warn(typeof message === 'object' ? JSON.stringify(message) : message, { context });
  }

  debug(message: any, context?: string): void {
    this.logger.debug(typeof message === 'object' ? JSON.stringify(message) : message, { context });
  }

  verbose(message: any, context?: string): void {
    this.logger.verbose(typeof message === 'object' ? JSON.stringify(message) : message, { context });
  }
}
```

### 3.7 修改主入口文件

**文件路径**：[src/main.ts](./src/main.ts)

```typescript
import 'dotenv/config';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { GlobalExceptionFilter } from './common/filters/global-exception.filter';
import { ResponseInterceptor } from './common/interceptors/response.interceptor';
import { LoggingInterceptor } from './common/interceptors/logging.interceptor';
import { WinstonLoggerService } from './common/services/logger.service';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, {
    logger: new WinstonLoggerService(), // 使用 WinstonLoggerService 作为日志服务
  });
  
  // 使用全局异常过滤器
  app.useGlobalFilters(new GlobalExceptionFilter());
  
  // 使用全局响应拦截器，确保所有成功响应都包含 traceId
  app.useGlobalInterceptors(new ResponseInterceptor());
  
  // 使用全局日志拦截器，自动记录请求的 traceId、入参和结果
  app.useGlobalInterceptors(new LoggingInterceptor());
  
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
```



## 4. 日志文件说明

- `logs/application-%DATE%.log`：记录所有级别的日志，包含请求参数、响应结果等详细信息
- `logs/error-%DATE%.log`：仅记录错误级别的日志
- `logs/exceptions-%DATE%.log`：记录未捕获的异常

## 5. 功能验证

### 5.1 成功响应
- 发送 GET 请求到 `/phone`
- 响应体格式：`{ success: true, data: {...}, traceId: "..." }`
- 响应头包含：`X-Trace-Id: "..."`

### 5.2 错误响应
- 发送错误请求（如不存在的 ID）
- 响应体格式：`{ success: false, message: "...", traceId: "..." }`
- 响应头包含：`X-Trace-Id: "..."`

### 5.3 日志验证
- 查看 `logs` 目录下的日志文件
- 每条日志都包含 traceId，格式为 `[traceId] 日志内容`

## 6. 性能考虑

当前实现使用同步日志写入，对于高并发系统可能会影响性能。如需优化，可考虑：
- 使用异步日志写入
- 配置日志批量写入
- 使用内存缓冲区
- 实施日志采样策略